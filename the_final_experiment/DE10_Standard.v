
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================


module DE10_Standard(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// Seg7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// Audio //////////
	input 		          		AUD_ADCDAT,
	inout 		          		AUD_ADCLRCK,
	inout 		          		AUD_BCLK,
	output		          		AUD_DACDAT,
	inout 		          		AUD_DACLRCK,
	output		          		AUD_XCK,

	//////////// PS2 //////////
	inout 		          		PS2_CLK,
	inout 		          		PS2_CLK2,
	inout 		          		PS2_DAT,
	inout 		          		PS2_DAT2,

	//////////// I2C for Audio and Video-In //////////
	output		          		FPGA_I2C_SCLK,
	inout 		          		FPGA_I2C_SDAT
);



//=======================================================
//  REG/WIRE declarations
//=======================================================
	//设备内部信号，无需外部控制
	wire memclock;
	wire clock;
	reg [3:0] counter;
	//VGA部分
	wire cpuMem_w;
	wire [31:0] cpuMem_in_addr;
	///*
	wire [31:0] cpuMem_in_data;
	wire [31:0] cpuMem_out_data1;
	wire [31:0] cpuMem_out_data2;
	reg [31:0] cpuMem_out_data;
	//*/
	/*
	{cpuMem_in_data[7:0],cpuMem_in_data[15:8],cpuMem_in_data[23:16],cpuMem_in_data[31:24]}
	{cpuMem_out_data1[7:0],cpuMem_out_data1[15:8],cpuMem_out_data1[23:16],cpuMem_out_data1[31:24]}
	{cpuMem_out_data2[7:0],cpuMem_out_data2[15:8],cpuMem_out_data2[23:16],cpuMem_out_data2[31:24]}
	{cpuMem_out_data[7:0],cpuMem_out_data[15:8],cpuMem_out_data[23:16],cpuMem_out_data[31:24]}
	{keyboard_data[7:0],keyboard_data[15:8],keyboard_data[23:16],keyboard_data[31:24]}
	*/
	/*
	wire [0:31] cpuMem_in_data;
	wire [0:31] cpuMem_out_data1;
	wire [0:31] cpuMem_out_data2;
	wire [0:31] cpuMem_out_data;
	*/
	wire [11:0] font_address;
	wire [31:0] char;

	//键盘部分
	wire [18:0] k_addr;
	wire [31:0] keyboard_data;
	wire k_change;
	wire k_clear;
	wire [18:0] k_pos;
	reg [18:0] c_k_pos;
	
	reg [31:0] r_w_addr;
	
	wire [511:0]  device_state;
	
	//设备状态信号，需要外部控制
	wire [2:0] show_model;//是否显示图标选择
	wire [2:0] background;//背景选择
	wire [2:0] move_model;//运动模式选择 废弃
	wire [2:0] font_model;//字体模式选择
	wire [11:0] font_color;//字体颜色
	wire [2:0] choose_icon;//用以知道选中了那个图标
	wire reset;//重启
	wire [3:0] volume;
	
	wire [7:0] sound_ram;
	
	//Debug用
	wire [31:0] term_pc;

	
//=======================================================
//  Structural coding
//=======================================================
	initial
	begin
		//memclock = clock;
		counter = 0;
		r_w_addr = 0;
		cpuMem_out_data = 0;
	end
	
	
	assign clock = counter[3];
	assign memclock = counter[0];
	always@(posedge CLOCK_50)
		counter = counter + 1;

	VGA VGA_model(.CLOCK2_50(CLOCK2_50),.CLOCK3_50(CLOCK3_50),.CLOCK4_50(CLOCK4_50),.CLOCK_50(CLOCK_50),
				.KEY(KEY),.SW(SW),.LEDR(),
				.HEX0(),.HEX1(),.HEX2(),.HEX3(),.HEX4(),.HEX5(),.VGA_BLANK_N(VGA_BLANK_N),
				.VGA_B(VGA_B),.VGA_CLK(VGA_CLK),.VGA_G(VGA_G),.VGA_HS(VGA_HS),
				.VGA_R(VGA_R),.VGA_SYNC_N(VGA_SYNC_N),.VGA_VS(VGA_VS),
				.PS2_CLK(),.PS2_CLK2(),.PS2_DAT(),.PS2_DAT2(),
				
				.show_model(show_model), .background(background), .move_model(move_model), .font_model(font_model), .font_color(font_color),
				.choose_icon({1'b0,choose_icon[1:0]}),
				.font_address(font_address), .char(char)
	);
	
	Keyboard Keyboard_model(.CLOCK2_50(CLOCK2_50),.CLOCK3_50(CLOCK3_50),.CLOCK4_50(CLOCK4_50),.CLOCK_50(VGA_CLK),//注意：这里CLOCK_50改为了VGA_CLK
				.KEY(),.SW(),.LEDR(),
				.HEX0(),.HEX1(),.HEX2(),.HEX3(),.HEX4(),.HEX5(),
				.VGA_BLANK_N(),.VGA_B(),.VGA_CLK(VGA_CLK),.VGA_G(),.VGA_HS(),
				.VGA_R(),.VGA_SYNC_N(),.VGA_VS(),
				.PS2_CLK(PS2_CLK),.PS2_CLK2(PS2_CLK2),.PS2_DAT(PS2_DAT),.PS2_DAT2(PS2_DAT2),
				
				.k_addr(k_addr), .keyboard_data(keyboard_data), .k_change(k_change), .clear(1'b0), .pos(k_pos)
	);
	
	Sound sound_model(.CLOCK2_50(CLOCK2_50),.CLOCK3_50(CLOCK3_50),.CLOCK4_50(CLOCK4_50),.CLOCK_50(CLOCK_50),
							.KEY(4'h1),.SW(),.LEDR(),.HEX0(),.HEX1(),.HEX2(),.HEX3(),.HEX4(),.HEX5(),
							.AUD_ADCDAT(AUD_ADCDAT),.AUD_ADCLRCK(AUD_ADCLRCK),.AUD_BCLK(AUD_BCLK),.AUD_DACDAT(AUD_DACDAT),.AUD_DACLRCK(AUD_DACLRCK),.AUD_XCK(AUD_XCK),
							.PS2_CLK(),.PS2_CLK2(),.PS2_DAT(),.PS2_DAT2(),.FPGA_I2C_SCLK(FPGA_I2C_SCLK),.FPGA_I2C_SDAT(FPGA_I2C_SDAT),
							.ps2_clk(),.ps2_data(),.ascll(sound_ram[7:0]),.volume(volume)
	);
	digital_tube(sound_ram[3:0], 1'b1, HEX0);
	digital_tube(sound_ram[7:4], 1'b1, HEX1);
	digital_tube(cpuMem_in_addr[16:13], 1'b1, HEX2);

	
	//assign cpuMem_out_data = (cpuMem_out_data[12:2] != 0)?cpuMem_out_data1:cpuMem_out_data2;//只有当低位全为0的时候，才会读状态寄存器的值
	//assign cpuMem_out_data = cpuMem_out_data1;
	/*
	digital_tube(term_pc[3:0], 1'b1, HEX0);
	digital_tube(term_pc[7:4], 1'b1, HEX1);
	digital_tube(term_pc[11:8], 1'b1, HEX2);
	digital_tube(term_pc[15:12], 1'b1, HEX3);
	digital_tube(term_pc[19:16], 1'b1, HEX4);
	digital_tube(term_pc[23:20], 1'b1, HEX5);
	*/
	ldw_CPU CPU_model(.clock(clock), .resetn(~reset), .pc(term_pc), .inst(), .ealu(), .malu(), .walu(),
						.cpuMem_w(cpuMem_w), .cpuMem_in_addr(cpuMem_in_addr), .cpuMem_in_data(cpuMem_in_data), .cpuMem_out_data(cpuMem_out_data));
	
	//ldw_MEM MEM_model(.we(cpuMem_w), .addr(cpuMem_in_addr), .datain({cpuMem_in_data[7:0],cpuMem_in_data[15:8],cpuMem_in_data[23:16],cpuMem_in_data[31:24]}), .clk(clock), .inclk(memclock), .outclk(memclock), .dataout({cpuMem_out_data[7:0],cpuMem_out_data[15:8],cpuMem_out_data[23:16],cpuMem_out_data[31:24]}));

	always@(posedge VGA_CLK)
	begin
		c_k_pos <= k_pos;
		if(c_k_pos == k_pos)
			r_w_addr <= {1'b0,19'b0,font_address[11:0]};
		else
			r_w_addr <= {1'b1,19'b0,k_addr[11:0]};//记得为其预留空间，以防改变其他的重要内存
	end
	
	Mem mem_model(.address_a(cpuMem_in_addr[12:2]),.address_b(r_w_addr[12:2]),
						.clock_a(memclock),.clock_b(VGA_CLK),
						.data_a({cpuMem_in_data[7:0],cpuMem_in_data[15:8],cpuMem_in_data[23:16],cpuMem_in_data[31:24]}),
						.data_b({keyboard_data[7:0],keyboard_data[15:8],keyboard_data[23:16],keyboard_data[31:24]}),
						.rden_a(1'b1),.rden_b(~r_w_addr[31]),
						.wren_a(cpuMem_w && (cpuMem_in_addr[15:13] == 3'b000)),.wren_b(r_w_addr[31]),
						.q_a({cpuMem_out_data1[7:0],cpuMem_out_data1[15:8],cpuMem_out_data1[23:16],cpuMem_out_data1[31:24]}),
						.q_b(char));
	
	//assign cpuMem_out_data = (cpuMem_in_addr[15:2] != 0)?cpuMem_out_data1:cpuMem_out_data2;//可能有问题
	always@(cpuMem_in_addr)
		case(cpuMem_in_addr[15:13])
			3'b000: cpuMem_out_data = cpuMem_out_data1;
			3'b001: cpuMem_out_data = cpuMem_out_data2;
			3'b011: cpuMem_out_data = sound_ram;
			default: cpuMem_out_data = 32'h31323334;
		endcase
	/*
	assign show_model		=	device_state[2 +32*0 :0+32*0];
	assign background		=	device_state[2 +32*1 :0+32*1];
	assign move_model		=	device_state[2 +32*2 :0+32*2];//废弃
	assign font_model		=	device_state[2 +32*3 :0+32*3];
	assign font_color		=	device_state[11 +32*4 :0+32*4];
	assign choose_icon	=	device_state[2 +32*5 :0+32*5];
	assign LEDR				=	device_state[9 +32*6 :0+32*6];
	assign HEX0				=	device_state[6 +32*7 :0+32*7];
	assign HEX1				=	device_state[6 +32*8 :0+32*8];
	assign HEX2				=	device_state[6 +32*9 :0+32*9];
	assign HEX3				=	device_state[6 +32*10:0+32*10];
	assign HEX4				=	device_state[6 +32*11:0+32*11];
	assign HEX5				=	device_state[6 +32*12:0+32*12];
	assign reset			=	device_state[0+32*13];
	*/
	assign show_model		=	device_state[2 +32*(0)+24 :0+32*(0)+24];
	assign background		=	device_state[2 +32*(1)+24 :0+32*(1)+24];
	assign move_model		=	device_state[2 +32*(2)+24 :0+32*(2)+24];//废弃
	assign font_model		=	device_state[2 +32*(3)+24 :0+32*(3)+24];
	assign font_color		=	device_state[7 +32*(4)+24 :0+32*(4)+24];//此处尚有问题
	assign choose_icon	=	device_state[2 +32*(5)+24 :0+32*(5)+24];
	assign LEDR				=	device_state[9 +32*(6)+24 :0+32*(6)+24];
	assign HEX0				=	device_state[6 +32*(7)+24 :0+32*(7)+24];
	assign HEX1				=	device_state[6 +32*(8)+24 :0+32*(8)+24];
	assign HEX2				=	device_state[6 +32*(9)+24 :0+32*(9)+24];
	assign HEX3				=	device_state[6 +32*(10)+24:0+32*(10)+24];
	assign HEX4				=	device_state[6 +32*(11)+24:0+32*(11)+24];
	assign HEX5				=	device_state[6 +32*(12)+24:0+32*(12)+24];
	assign reset			=	device_state[              0+32*(13)+24];
	assign sound_ram		=	device_state[7 +32*(2)+24:0+32*(2)+24];
	
	device_state_Mem device_state_mem(.address_a(cpuMem_in_addr[20:16]),.address_b(1'b0),
													.clock_a(memclock),.clock_b(clock),
													.data_a({cpuMem_in_data[7:0],cpuMem_in_data[15:8],cpuMem_in_data[23:16],cpuMem_in_data[31:24]}),.data_b(32'h0),
													.wren_a(cpuMem_w && (cpuMem_in_addr[15:13] == 3'b001)),.wren_b(reset),
													.q_a({cpuMem_out_data2[7:0],cpuMem_out_data2[15:8],cpuMem_out_data2[23:16],cpuMem_out_data2[31:24]}),.q_b(device_state));
	
	//always@(posedge memclock)
	//	if( (cpuMem_in_addr[15:13] == 3'b011) && cpuMem_w)
	//		begin
		//		sound_ram <= {cpuMem_in_data[31:24]};
	//		end
		//sound_ram <= (cpuMem_in_addr[15:13] == 3'b011)?{cpuMem_in_data[7:0],cpuMem_in_data[15:8],cpuMem_in_data[23:16],cpuMem_in_data[31:24]}:sound_ram;
		//sound_ram <= {cpuMem_in_data[7:0],cpuMem_in_data[15:8],cpuMem_in_data[23:16],cpuMem_in_data[31:24]};
	
	
endmodule 